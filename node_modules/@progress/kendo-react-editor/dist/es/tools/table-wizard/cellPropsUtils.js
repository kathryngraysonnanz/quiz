var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
import { htmlToFragment } from '@progress/kendo-editor-common';
import { getUnit, parseStyle, selectedCells, setNodeStyle, tableCells } from './utils';
import { parentNode } from '../utils';
var colgroupAttr = 'k-colgroup-data';
var cellsWidth = function (cells, table, $pos) {
    var result = {
        cellWidth: null,
        widthUnit: ''
    };
    var tableNode = table.node;
    var tablePos = $pos.start(table.depth);
    if (!tableNode.attrs[colgroupAttr]) {
        return result;
    }
    var width = new Set();
    var value = '';
    var colgroup = htmlToFragment(tableNode.attrs[colgroupAttr]).firstChild;
    cells.forEach(function (cell) {
        var $cell = tableNode.resolve(cell.pos - tablePos);
        var row = $cell.parent;
        var cellIndex = $cell.index();
        var colSpan = 0;
        for (var i = 0; i <= cellIndex; i++) {
            colSpan += row.child(i).attrs.colspan;
        }
        var col = colgroup.children[colSpan - 1];
        if (col) {
            value = col.style.width;
            width.add(value);
        }
    });
    if (width.size === 1 && value) {
        result.cellWidth = parseFloat(value) || null;
        result.widthUnit = getUnit(value);
    }
    return result;
};
var cellsHeight = function (cells, table, $pos) {
    var result = {
        cellHeight: null,
        heightUnit: ''
    };
    var tableNode = table.node;
    var tablePos = $pos.start(table.depth);
    var height = new Set();
    var value = '';
    cells.forEach(function (cell) {
        var _a;
        var $cell = tableNode.resolve(cell.pos - tablePos);
        var row = $cell.parent;
        value = parseStyle(((_a = row.attrs) === null || _a === void 0 ? void 0 : _a.style) || '').height || '';
        height.add(value);
    });
    if (height.size === 1 && value) {
        result.cellHeight = parseFloat(value) || null;
        result.heightUnit = getUnit(value);
    }
    return result;
};
var cellsStyle = function (cells, style) {
    var values = new Set();
    var value = '';
    cells.forEach(function (cell) {
        var _a;
        value = parseStyle(((_a = cell.node.attrs) === null || _a === void 0 ? void 0 : _a.style) || '')[style] || '';
        values.add(value);
    });
    if (values.size === 1 && value) {
        return value;
    }
    return '';
};
var cellsProp = function (cells, prop) {
    var values = new Set();
    var value = '';
    cells.forEach(function (cell) {
        value = (cell.node.attrs || {})[prop] || '';
        values.add(value);
    });
    if (values.size === 1 && value) {
        return value;
    }
    return '';
};
/**
 * @hidden
 */
var initialCellData = {
    applyToAll: false,
    cellWidth: null,
    widthUnit: '',
    cellHeight: null,
    heightUnit: '',
    alignment: { x: '', y: '' },
    textControl: '',
    backgroundColor: undefined,
    cellPadding: null,
    borderWidth: null,
    borderColor: undefined,
    borderStyle: null,
    id: '',
    className: ''
};
/**
 * @hidden
 */
var cellsDefaultData = function (state) {
    var cells = selectedCells(state);
    var $pos = state.selection.$from;
    var table = cells.length ? parentNode($pos, function (n) { return n.type.spec.tableRole === 'table'; }) : null;
    if (!table) {
        return initialCellData;
    }
    return __assign(__assign(__assign(__assign({}, initialCellData), cellsWidth(cells, table, $pos)), cellsHeight(cells, table, $pos)), { alignment: { x: cellsStyle(cells, 'text-align'), y: cellsStyle(cells, 'vertical-align') }, textControl: cellsStyle(cells, 'white-space'), backgroundColor: cellsStyle(cells, 'background-color') || undefined, cellPadding: parseFloat(cellsStyle(cells, 'padding')) || null, borderWidth: parseFloat(cellsStyle(cells, 'border-width')) || null, borderColor: cellsStyle(cells, 'border-color') || undefined, borderStyle: cellsStyle(cells, 'border-style') || null, id: cellsProp(cells, 'id'), className: cellsProp(cells, 'class') });
};
var setCellWidth = function (tr, pos, width) {
    var _a, _b;
    var $cell = tr.doc.resolve(pos);
    var row = $cell.parent;
    var cellIndex = $cell.index();
    var colSpan = 0;
    for (var i = 0; i <= cellIndex; i++) {
        colSpan += row.child(i).attrs.colspan;
    }
    var tableNode = $cell.node($cell.depth - 1);
    var tablePos = $cell.posAtIndex(0, $cell.depth - 1) - 1;
    var attrs = tableNode.attrs;
    var col;
    if (attrs && attrs[colgroupAttr]) {
        // const colgroup = parseStrColgroup(tableNode.attrs[colgroupAttr]);
        var colgroup = htmlToFragment(attrs[colgroupAttr]).firstChild;
        col = colgroup.children[colSpan - 1];
        col.style.width = width;
        attrs = __assign(__assign({}, attrs), (_a = {}, _a[colgroupAttr] = colgroup.outerHTML, _a));
        tr.setNodeMarkup(tablePos, null, attrs);
    }
    else {
        var total = 0;
        for (var i = 0; i < row.childCount; i++) {
            total += row.child(i).attrs.colspan;
        }
        var colgroup = document.createElement('colgroup');
        var cols = new Array(total);
        for (var i = 0; i < total; i++) {
            cols[i] = document.createElement('col');
            colgroup.appendChild(cols[i]);
        }
        col = cols[cellIndex];
        col.style.width = width;
        attrs = __assign(__assign({}, attrs), (_b = {}, _b[colgroupAttr] = '<colgroup>' + cols.reduce(function (acc, cur) { return acc + cur.outerHTML; }, '') + '</colgroup>', _b));
        tr.setNodeMarkup(tablePos, null, attrs);
    }
};
var setCellHeight = function (tr, pos, height) {
    var $cell = tr.doc.resolve(pos);
    var row = $cell.parent;
    var rowPos = $cell.posAtIndex(0) - 1;
    tr.setNodeMarkup(rowPos, null, setNodeStyle(row.attrs, 'height', height));
};
var applyOnCell = function (tr, data, cells) {
    cells.forEach(function (_a) {
        var node = _a.node, pos = _a.pos;
        var attrs = __assign({}, node.attrs);
        attrs = setNodeStyle(attrs, 'border-color', data.borderColor || '');
        attrs = setNodeStyle(attrs, 'border-style', data.borderStyle || '');
        attrs = setNodeStyle(attrs, 'border-width', typeof data.borderWidth === 'number' ? data.borderWidth + 'px' : '');
        attrs = setNodeStyle(attrs, 'padding', typeof data.cellPadding === 'number' ? data.cellPadding + 'px' : '');
        attrs = setNodeStyle(attrs, 'background-color', data.backgroundColor || '');
        attrs = setNodeStyle(attrs, 'text-align', data.alignment.x || '');
        attrs = setNodeStyle(attrs, 'vertical-align', data.alignment.y || '');
        attrs = setNodeStyle(attrs, 'white-space', data.textControl || '');
        attrs.id = data.id || null;
        attrs.class = data.className || null;
        tr.setNodeMarkup(pos, null, attrs);
        if (typeof data.cellWidth === 'number') {
            setCellWidth(tr, pos, data.cellWidth + (data.widthUnit || 'px'));
        }
        if (typeof data.cellHeight === 'number') {
            setCellHeight(tr, pos, data.cellHeight + (data.heightUnit || 'px'));
        }
    });
};
/**
 * @hidden
 */
var applyCellsData = function (state, data) {
    var tr = state.tr;
    var cells = data.applyToAll ? tableCells(state) : selectedCells(state);
    applyOnCell(tr, data, cells);
    return tr;
};
export { initialCellData, cellsDefaultData, applyCellsData };
