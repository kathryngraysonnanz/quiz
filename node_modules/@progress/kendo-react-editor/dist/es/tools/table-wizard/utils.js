var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
import { TableMap } from '@progress/kendo-editor-common';
import { parentNode } from '../utils';
/**
 * @hidden
 */
export var reUnit = /[\D]+$/;
/**
 * @hidden
 */
export var getUnit = function (value) {
    var unitsMatch = value.match(reUnit);
    return unitsMatch ? unitsMatch[0] : '';
};
/**
 * @hidden
 */
export var nodeSize = function (node, style) {
    var _a;
    var _b;
    var value = parseStyle(((_b = node.attrs) === null || _b === void 0 ? void 0 : _b.style) || '')[style] || '';
    return _a = {},
        _a[style] = parseFloat(value) || null,
        _a[style + 'Unit'] = getUnit(value),
        _a;
};
/**
 * @hidden
 */
export var parseStyle = function (styleText) {
    var styles = (styleText || '').split(/\s*;\s*/).filter(Boolean).map(function (s) {
        var _a;
        var nameValue = s.split(/\s*:\s*/);
        return _a = {}, _a[nameValue[0]] = nameValue[1], _a;
    }).reduce(function (acc, val) { return (__assign(__assign({}, acc), val)); }, {});
    return styles;
};
var changeStylesString = function (styleText, newStyle) {
    var styleToChange = newStyle.style;
    var regExp = newStyle.value;
    var newValue = newStyle.newValue;
    if (!styleText) {
        return { changed: false, style: null };
    }
    var styles = styleText.split(/\s*;\s*/).filter(function (s) { return Boolean(s); });
    var filtered = styles.filter(function (s) {
        var nameValue = s.split(/\s*:\s*/);
        return !(nameValue[0].toLowerCase() === styleToChange && regExp.test(nameValue[1]));
    });
    if (newValue) {
        filtered.push("".concat(styleToChange, ": ").concat(newValue));
    }
    return {
        style: filtered.join('; ') + (filtered.length ? ';' : ''),
        changed: Boolean(newValue) || filtered.length !== styles.length
    };
};
var reAnyValue = /^.+$/;
/**
 * @hidden
 */
export function setNodeStyle(nodeAttrs, styleType, value) {
    var attrs;
    if (new RegExp('[^-]?' + styleType + ':').test(nodeAttrs.style || '')) {
        var style = changeStylesString(nodeAttrs.style || '', { style: styleType, value: reAnyValue, newValue: value }).style;
        attrs = __assign(__assign({}, nodeAttrs), { style: style });
    }
    else if (nodeAttrs.style) {
        var st_1 = parseStyle(nodeAttrs.style);
        st_1[styleType] = value;
        attrs = __assign(__assign({}, nodeAttrs), { style: Object.keys(st_1).filter(function (s) { return Boolean(st_1[s]); }).reduce(function (acc, cur) { return acc + cur + ': ' + st_1[cur] + '; '; }, '').trim() });
    }
    else {
        if (value) {
            attrs = __assign(__assign({}, nodeAttrs), { style: styleType + ': ' + value + ';' });
        }
        else {
            attrs = __assign({}, nodeAttrs);
        }
    }
    return attrs;
}
var getCells = function (state) {
    var doc = state.doc, selection = state.selection;
    var result = [];
    selection.ranges.forEach(function (range) {
        var from = range.$from.pos;
        var to = range.$to.pos;
        doc.nodesBetween(from, to, function (node, pos, _parent, _index) {
            if (node.type.name === 'table_cell' || node.type.name === 'table_header') {
                result.push({ node: node, pos: pos });
            }
        });
    });
    return result;
};
/**
 * @hidden
 */
export var selectedCells = function (state) {
    var startNodeTable = parentNode(state.selection.$from, function (n) { return n.type.name === 'table'; });
    var endNodeTable = parentNode(state.selection.$to, function (n) { return n.type.name === 'table'; });
    if (startNodeTable && endNodeTable && startNodeTable.depth === endNodeTable.depth && startNodeTable.node.eq(endNodeTable.node)) {
        var cells = getCells(state).filter(function (_a) {
            var pos = _a.pos;
            var parentTable = parentNode(state.doc.resolve(pos), function (n) { return n.type.name === 'table'; });
            return parentTable && parentTable.depth === startNodeTable.depth && startNodeTable.node.eq(parentTable.node);
        });
        return cells;
    }
    return [];
};
/**
 * @hidden
 */
export var tableCells = function (state) {
    var cells = [];
    if (selectedCells(state).length) {
        var $pos = state.selection.$from;
        var parentTable = parentNode($pos, function (n) { return n.type.spec.tableRole === 'table'; });
        if (parentTable === null) {
            return cells;
        }
        var tablePos_1 = $pos.start(parentTable.depth);
        var tableNode = parentTable.node;
        var map = TableMap.get(tableNode);
        var doc_1 = state.doc;
        map.map.forEach(function (m) {
            var pos = m + tablePos_1;
            cells.push({ pos: pos, node: doc_1.nodeAt(pos) });
        });
    }
    return cells;
};
